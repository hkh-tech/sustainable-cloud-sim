# Sustainable Cloud Scheduler (pure Python)

A small, self-contained simulation that explores **carbon-aware workload scheduling** across cloud regions.
It uses a lightweight discrete‑event loop (`heapq`) and a simple (but non‑linear) server power model.
No external runtime dependencies are required to run the simulation.

## Why this exists
I wanted a reproducible, minimal code sample that still touches real questions in sustainable computing:
- How much can a **carbon-aware policy** help compared to round‑robin or random placement?
- What trade-offs appear when we **penalize latency** or allow short **deferrals**?
- How sensitive are results to basic **power model assumptions** and **grid carbon profiles**?

## How it works (short)
- There are several **nodes** (regions), each with capacity, PUE, and a time‑varying carbon intensity (gCO₂/kWh).
- Synthetic tasks arrive over time with CPU and duration requirements.
- The scheduler chooses a node according to a **policy**:
  - `carbon_greedy` (minimize estimated carbon)
  - `round_robin`
  - `random`
  - `carbon_latency_weighted` (minimize carbon + λ·latency)
- We record per‑task and per‑node **energy, carbon, and queue wait**. Plots and CSVs go to `artifacts/`.

## Quick start
```bash
python src/sim.py --policy carbon_greedy
python src/sim.py --policy round_robin
python src/sim.py --policy random
python src/sim.py --policy carbon_latency_weighted --max-wait 3
```
Artifacts:
- `artifacts/summary.csv` (per-task metrics)
- `artifacts/node_totals.csv` (per-node totals with avg wait)
- `artifacts/carbon_intensity.png`, `artifacts/node_energy.png`, `artifacts/node_carbon.png`

## Design notes (assumptions & knobs)
- **Power model.** I use a non‑linear utilization curve \(P(u) = P_\text{idle} + (P_\text{peak}-P_\text{idle})[\alpha u + (1-\alpha)u^2]\).
  - `alpha=0.6` keeps it close to linear but penalizes high utilization more than low.
  - Peak power is approximated from `base_kw + cpu_kw_per_core * capacity`.
- **Carbon profiles.** Piecewise‑constant per region. This is intentionally stylized so the effect of policies is visible.
- **Latency.** A fixed per‑region number (ms). In `carbon_latency_weighted`, the combined score is `carbon + λ·latency`.
  - Adjust `LAT_WEIGHT` to emphasize latency vs. carbon.
- **Deferral.** `--max-wait` allows small delays before forcing a placement.

If you change any of these, please note your choices (and why) in a short commit message.

## Baselines & trade‑offs
To avoid one “nice result”, the repo includes baseline policies. You can compare totals by running:
```bash
python src/experiments.py
```
This writes `artifacts/experiment_results.csv` with total energy and carbon for each policy.

## Limitations (on purpose)
- The power model ignores memory/IO/NIC and cooling dynamics; it’s meant for clarity.
- No job migration or fragmentation handling.
- Synthetic workload and stylized carbon data.
- No explicit data‑locality or egress cost modeling.

## Folder layout
```
sustainable-cloud-sim/
├─ README.md
├─ CHANGELOG.md
├─ LICENSE
├─ .gitignore
├─ src/
│  ├─ sim.py
│  └─ experiments.py
└─ artifacts/   # CSVs and PNG plots generated by the run
```

## License
MIT — see `LICENSE`.
